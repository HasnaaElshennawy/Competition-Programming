package TopCoder.Medium;import java.util.*;/* TopCoder SRM 436 * Medium Problem 500 Points: DoNotTurn * Type: Dijkstra * Solution: Dijkstra just barely works in time. Because edges costs are always 0 or 1 that means you can * use a deque (add to front of queue if cost 0, end if cost 1) and gain some efficeincy. */public class DoNotTurn {

	public int minimumTurns(int N, int X0, int A, int B, int Y0, int C, int D, int P, int M) {
		int[] x = new int[M];		int[] y = new int[M];		if(M > 0)		{		x[0] = X0 % P;		y[0] = Y0 % P;		}		for(int i = 1; i < M;i++)		{			x[i] = (int)((((long)x[i-1])*A+B)%P);			y[i] = (int)((((long)y[i-1])*C+D)%P);		}		int[][][] dist = new int[N][N][4];		for(int i = 0; i < dist.length;i++)			for(int j = 0; j < dist[0].length;j++)				Arrays.fill(dist[i][j],Integer.MAX_VALUE);		dist[0][0][0] = 0;		dist[0][0][1] = 0;		dist[0][0][2] = 0;		dist[0][0][3] = 0;		PriorityQueue<Node> pq = new PriorityQueue<Node>();		pq.add(new Node(0,0,0,0));		pq.add(new Node(0,0,1,0));		pq.add(new Node(0,0,2,0));		pq.add(new Node(0,0,3,0));		boolean[][] full = new boolean[N][N];		for(int i = 0; i < M;i++)		{			if(x[i]%N == 0 && y[i]%N == 0) continue;			if(x[i]%N == N-1 && y[i]%N == N-1) continue;			full[x[i]%N][y[i]%N] = true;		}		while(pq.size() > 0)		{			Node n = pq.poll();			//System.out.println(n.x+" "+n.y+" "+n.dir+" "+n.cost);			if(dist[n.x][n.y][n.dir] < n.cost) continue;			if(n.x == N-1 && n.y == N-1) return n.cost;						int dx = dirs[n.dir][0];			int dy = dirs[n.dir][1];			boolean good = true;						if(n.x+dx < 0 || n.x+dx >= N || n.y+dy < 0 || n.y+dy >= N) good = false;			//System.out.println("HERE "+good+" "+(good?full[n.x+dx][n.y+dy]:false) +" "+(good?dist[n.x+dx][n.y+dy][n.dir]:-1));			if(good && !full[n.x+dx][n.y+dy] && dist[n.x+dx][n.y+dy][n.dir] > n.cost)			{								dist[n.x+dx][n.y+dy][n.dir] = n.cost;				pq.add(new Node(n.x+dx,n.y+dy,n.dir,n.cost));			}			for(int ddir = -1;ddir<=1;ddir+=2)			{				if(dist[n.x][n.y][(n.dir+ddir+4)%4] > n.cost+1)				{					dist[n.x][n.y][(n.dir+ddir+4)%4] = n.cost+1;					pq.add(new Node(n.x,n.y,(n.dir+ddir+4)%4,n.cost+1));				}			}		}		return -1;
	}	int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};
	private static class Node implements Comparable<Node>	{		int x,y,dir,cost;		public Node(int a, int b, int c, int d)		{			x = a;			y = b;			dir = c;			cost = d;		}		public int compareTo(Node o) {			return Integer.valueOf(cost).compareTo(o.cost);					}			}
}
