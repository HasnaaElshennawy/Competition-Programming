package TopCoder.Easy;
import java.util.*;
import static java.util.Arrays.*;

/* TopCoder SRM 468
 * Easy Problem 250 Points: T9
 * Type: Simulation
 * Solution: Just run the algorithm. When you check to find all of the words that can be generated by some numbers just check each dictionary word
 * individually rather than generating all words then checking if they are in the dictionary.
 */

public class T9 {
	public void p(Object... s){System.out.println(deepToString(s));}
	public String message(String[] part, String[] dict, String[] keystr) {
		String S = "";
		for(String s:keystr)
			S += s;
		String ans = "";
		int at = 0;
		int N = S.length();

		while(at < N){
			while(at < N && S.charAt(at) == '0'){
				ans += " ";
				at++;
			}
			if(at == N)
				break;
			String word = "";
			while(at < N && S.charAt(at) != '0' && Character.isDigit(S.charAt(at))){
				word += S.charAt(at);
				at++;
			}
			int c = 0;
			while(at < N &&( S.charAt(at) == '*' || S.charAt(at) == '#')){
				c += S.charAt(at) == '#'?1:5;
				at++;
			}
			ans += word(part,dict,word,c);
		}
//		System.out.println(ans);
		return ans;
	}
	TreeSet<String> all;
	private String word(String[] P, String[] D, String W, int k) {
		all = new TreeSet<String>();
		for(String d:D){
			if(d.length() != W.length())
				continue;
			boolean same = true;
			for(int i = 0; i < W.length();i++){
				if(find(d,i,P) != W.charAt(i)-'0')
					same = false;
			}
			if(same)
				all.add(d);
		}
		int at = 0;
//		System.out.println(W+" "+all);
		for(String s:all){
			if(at == k)
				return s;
			at++;
		}
		return null;
	}
	private int find(String d, int a, String[] p) {
		for(int i = 0; i < p.length;i++){
			if(p[i].indexOf(d.charAt(a)) != -1)
				return i+1;
		}
		return -1;
	}
}
